/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.pydio.kotlin.openapi.kmp.api

import com.pydio.kotlin.openapi.kmp.model.IdmSearchUserMetaRequest
import com.pydio.kotlin.openapi.kmp.model.JobsCtrlCommand
import com.pydio.kotlin.openapi.kmp.model.RestActionParameters
import com.pydio.kotlin.openapi.kmp.model.RestBackgroundAction
import com.pydio.kotlin.openapi.kmp.model.RestBatchUpdateMetaList
import com.pydio.kotlin.openapi.kmp.model.RestCreateCheckRequest
import com.pydio.kotlin.openapi.kmp.model.RestCreateCheckResponse
import com.pydio.kotlin.openapi.kmp.model.RestCreateRequest
import com.pydio.kotlin.openapi.kmp.model.RestError
import com.pydio.kotlin.openapi.kmp.model.RestListTemplatesResponse
import com.pydio.kotlin.openapi.kmp.model.RestLookupRequest
import com.pydio.kotlin.openapi.kmp.model.RestNamespaceValuesOperation
import com.pydio.kotlin.openapi.kmp.model.RestNamespaceValuesResponse
import com.pydio.kotlin.openapi.kmp.model.RestNode
import com.pydio.kotlin.openapi.kmp.model.RestNodeCollection
import com.pydio.kotlin.openapi.kmp.model.RestNodeUpdates
import com.pydio.kotlin.openapi.kmp.model.RestPerformActionResponse
import com.pydio.kotlin.openapi.kmp.model.RestPublicLinkDeleteSuccess
import com.pydio.kotlin.openapi.kmp.model.RestPublicLinkRequest
import com.pydio.kotlin.openapi.kmp.model.RestSelection
import com.pydio.kotlin.openapi.kmp.model.RestShareLink
import com.pydio.kotlin.openapi.kmp.model.RestUserMetaList
import com.pydio.kotlin.openapi.kmp.model.RestUserMetaNamespaceCollection

import com.pydio.kotlin.openapi.kmp.infrastructure.*
import io.ktor.client.HttpClient
import io.ktor.client.HttpClientConfig
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import kotlinx.serialization.json.Json
import io.ktor.http.ParametersBuilder
import kotlinx.serialization.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*

open class NodeServiceApi : ApiClient {

    constructor(
        baseUrl: String = ApiClient.BASE_URL,
        httpClientEngine: HttpClientEngine? = null,
        httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
        jsonSerializer: Json = ApiClient.JSON_DEFAULT
    ) : super(baseUrl = baseUrl, httpClientEngine = httpClientEngine, httpClientConfig = httpClientConfig, jsonBlock = jsonSerializer)

    constructor(
        baseUrl: String,
        httpClient: HttpClient
    ): super(baseUrl = baseUrl, httpClient = httpClient)


    /**
     * enum for parameter name
     */
    @Serializable
    enum class NameBackgroundActionInfo(val value: kotlin.String) {
        
        @SerialName(value = "delete")
        delete("delete"),
        
        @SerialName(value = "restore")
        restore("restore"),
        
        @SerialName(value = "copy")
        copy("copy"),
        
        @SerialName(value = "move")
        move("move"),
        
        @SerialName(value = "extract")
        extract("extract"),
        
        @SerialName(value = "compress")
        compress("compress")
        
    }

    /**
     * Retrieve information about an action running in background
     * 
     * @param name 
     * @param jobUuid 
     * @return RestBackgroundAction
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun backgroundActionInfo(name: NameBackgroundActionInfo, jobUuid: kotlin.String): HttpResponse<RestBackgroundAction> {

        val localVariableAuthNames = listOf<String>("Bearer")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/n/action/{Name}/{JobUuid}".replace("{" + "Name" + "}", "${ name.value }").replace("{" + "JobUuid" + "}", "$jobUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Update/delete user meta in batch. Passed UserMetas must contain a NodeUuid
     * 
     * @param body 
     * @return RestBatchUpdateMetaList
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun batchUpdateMeta(body: RestBatchUpdateMetaList): HttpResponse<RestBatchUpdateMetaList> {

        val localVariableAuthNames = listOf<String>("Bearer")

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PATCH,
            "/n/meta/batch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }




    /**
     * enum for parameter name
     */
    @Serializable
    enum class NameControlBackgroundAction(val value: kotlin.String) {
        
        @SerialName(value = "delete")
        delete("delete"),
        
        @SerialName(value = "restore")
        restore("restore"),
        
        @SerialName(value = "copy")
        copy("copy"),
        
        @SerialName(value = "move")
        move("move"),
        
        @SerialName(value = "extract")
        extract("extract"),
        
        @SerialName(value = "compress")
        compress("compress")
        
    }

    /**
     * Send control commands to a background job
     * 
     * @param name 
     * @param jobUuid 
     * @param command 
     * @return RestBackgroundAction
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun controlBackgroundAction(name: NameControlBackgroundAction, jobUuid: kotlin.String, command: JobsCtrlCommand): HttpResponse<RestBackgroundAction> {

        val localVariableAuthNames = listOf<String>("Bearer")

        val localVariableBody = command

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PATCH,
            "/n/action/{Name}/{JobUuid}".replace("{" + "Name" + "}", "${ name.value }").replace("{" + "JobUuid" + "}", "$jobUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Create one or many files (empty or hydrated from a TemplateUuid) or folders
     * 
     * @param body 
     * @return RestNodeCollection
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun create(body: RestCreateRequest): HttpResponse<RestNodeCollection> {

        val localVariableAuthNames = listOf<String>("Bearer")

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/n/nodes/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Apply some pre-validation checks on node name before sending an upload
     * 
     * @param body Request for pre-checking nodes before uploading or creating them.
     * @return RestCreateCheckResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun createCheck(body: RestCreateCheckRequest): HttpResponse<RestCreateCheckResponse> {

        val localVariableAuthNames = listOf<String>("Bearer")

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/n/nodes/create/precheck",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Create a public link on a given node
     * 
     * @param uuid 
     * @param publicLinkRequest 
     * @return RestShareLink
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun createPublicLink(uuid: kotlin.String, publicLinkRequest: RestPublicLinkRequest): HttpResponse<RestShareLink> {

        val localVariableAuthNames = listOf<String>("Bearer")

        val localVariableBody = publicLinkRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/n/node/{Uuid}/link".replace("{" + "Uuid" + "}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Create and persist a temporary selection of nodes, that can be used by other actions
     * 
     * @param body Request to create a selection from a list of nodes.
     * @return RestSelection
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun createSelection(body: RestSelection): HttpResponse<RestSelection> {

        val localVariableAuthNames = listOf<String>("Bearer")

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/n/selection",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Remove a public link
     * 
     * @param linkUuid 
     * @return RestPublicLinkDeleteSuccess
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun deletePublicLink(linkUuid: kotlin.String): HttpResponse<RestPublicLinkDeleteSuccess> {

        val localVariableAuthNames = listOf<String>("Bearer")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/n/link/{LinkUuid}".replace("{" + "LinkUuid" + "}", "$linkUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Load a node by its Uuid
     * 
     * @param uuid 
     * @param path  (optional)
     * @return RestNode
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getByUuid(uuid: kotlin.String, path: kotlin.String? = null): HttpResponse<RestNode> {

        val localVariableAuthNames = listOf<String>("Bearer")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        path?.apply { localVariableQuery["Path"] = listOf("$path") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/n/node/{Uuid}".replace("{" + "Uuid" + "}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Load public link information by Uuid
     * 
     * @param linkUuid 
     * @return RestShareLink
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getPublicLink(linkUuid: kotlin.String): HttpResponse<RestShareLink> {

        val localVariableAuthNames = listOf<String>("Bearer")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/n/link/{LinkUuid}".replace("{" + "LinkUuid" + "}", "$linkUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * enum for parameter operationOperation
     */
    @Serializable
    enum class OperationOperationListNamespaceValues(val value: kotlin.String) {
        
        @SerialName(value = "PUT")
        PUT("PUT"),
        
        @SerialName(value = "DELETE")
        DELETE("DELETE")
        
    }

    /**
     * List values for a given namespace
     * 
     * @param namespace List persisted values for this namespace
     * @param operationOperation  (default to PUT)
     * @param operationValues 
     * @return RestNamespaceValuesResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listNamespaceValues(namespace: kotlin.String, operationOperation: OperationOperationListNamespaceValues = OperationOperationListNamespaceValues.PUT, operationValues: kotlin.collections.List<kotlin.String>): HttpResponse<RestNamespaceValuesResponse> {

        val localVariableAuthNames = listOf<String>("Bearer")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        operationOperation?.apply { localVariableQuery["Operation.Operation"] = listOf("${ operationOperation.value }") }
        operationValues?.apply { localVariableQuery["Operation.Values"] = toMultiValue(this, "multi") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/n/meta/namespace/{Namespace}".replace("{" + "Namespace" + "}", "$namespace"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List defined meta namespaces
     * 
     * @return RestUserMetaNamespaceCollection
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listNamespaces(): HttpResponse<RestUserMetaNamespaceCollection> {

        val localVariableAuthNames = listOf<String>("Bearer")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/n/meta/namespace",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List all known versions of a node
     * 
     * @param uuid 
     * @param path  (optional)
     * @return RestNodeCollection
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listVersions(uuid: kotlin.String, path: kotlin.String? = null): HttpResponse<RestNodeCollection> {

        val localVariableAuthNames = listOf<String>("Bearer")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        path?.apply { localVariableQuery["Path"] = listOf("$path") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/n/node/{Uuid}/versions".replace("{" + "Uuid" + "}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Generic request to either list (using Locators) or search (using Query) for nodes
     * 
     * @param body 
     * @return RestNodeCollection
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun lookup(body: RestLookupRequest): HttpResponse<RestNodeCollection> {

        val localVariableAuthNames = listOf<String>("Bearer")

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/n/nodes",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * PatchNode is used to update a node specific meta. It is used for reserved meta as well (bookmarks, contentLock)
     * 
     * @param uuid 
     * @param nodeUpdates 
     * @return RestNode
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun patchNode(uuid: kotlin.String, nodeUpdates: RestNodeUpdates): HttpResponse<RestNode> {

        val localVariableAuthNames = listOf<String>("Bearer")

        val localVariableBody = nodeUpdates

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PATCH,
            "/n/node/{Uuid}".replace("{" + "Uuid" + "}", "$uuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }




    /**
     * enum for parameter name
     */
    @Serializable
    enum class NamePerformAction(val value: kotlin.String) {
        
        @SerialName(value = "delete")
        delete("delete"),
        
        @SerialName(value = "restore")
        restore("restore"),
        
        @SerialName(value = "copy")
        copy("copy"),
        
        @SerialName(value = "move")
        move("move"),
        
        @SerialName(value = "extract")
        extract("extract"),
        
        @SerialName(value = "compress")
        compress("compress")
        
    }

    /**
     * Trigger an action on the tree. Returns a JobInfo describing a background task.
     * 
     * @param name 
     * @param parameters 
     * @param jobUuid  (optional)
     * @return RestPerformActionResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun performAction(name: NamePerformAction, parameters: RestActionParameters, jobUuid: kotlin.String? = null): HttpResponse<RestPerformActionResponse> {

        val localVariableAuthNames = listOf<String>("Bearer")

        val localVariableBody = parameters

        val localVariableQuery = mutableMapOf<String, List<String>>()
        jobUuid?.apply { localVariableQuery["JobUuid"] = listOf("$jobUuid") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/n/action/{Name}".replace("{" + "Name" + "}", "${ name.value }"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Search a list of meta by node Id or by User id and by namespace
     * 
     * @param body 
     * @return RestUserMetaList
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun searchMeta(body: IdmSearchUserMetaRequest): HttpResponse<RestUserMetaList> {

        val localVariableAuthNames = listOf<String>("Bearer")

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/n/meta/find",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * List available templates for hydrating empty files
     * 
     * @param templateType  (optional)
     * @return RestListTemplatesResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun templates(templateType: kotlin.String? = null): HttpResponse<RestListTemplatesResponse> {

        val localVariableAuthNames = listOf<String>("Bearer")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        templateType?.apply { localVariableQuery["TemplateType"] = listOf("$templateType") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/n/templates",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Add/delete a values for a given namespace
     * 
     * @param namespace List persisted values for this namespace
     * @param operation 
     * @return RestNamespaceValuesResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun updateNamespaceValues(namespace: kotlin.String, operation: RestNamespaceValuesOperation): HttpResponse<RestNamespaceValuesResponse> {

        val localVariableAuthNames = listOf<String>("Bearer")

        val localVariableBody = operation

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PATCH,
            "/n/meta/namespace/{Namespace}".replace("{" + "Namespace" + "}", "$namespace"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Update public link settings
     * 
     * @param linkUuid 
     * @param publicLinkRequest 
     * @return RestShareLink
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun updatePublicLink(linkUuid: kotlin.String, publicLinkRequest: RestPublicLinkRequest): HttpResponse<RestShareLink> {

        val localVariableAuthNames = listOf<String>("Bearer")

        val localVariableBody = publicLinkRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PATCH,
            "/n/link/{LinkUuid}".replace("{" + "LinkUuid" + "}", "$linkUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Special API for Bookmarks, will load userMeta and the associated nodes, and return as a node list
     * 
     * @param all  (optional)
     * @return RestNodeCollection
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun userBookmarks(all: kotlin.Boolean? = null): HttpResponse<RestNodeCollection> {

        val localVariableAuthNames = listOf<String>("Bearer")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        all?.apply { localVariableQuery["All"] = listOf("$all") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/n/nodes/bookmarks",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


}

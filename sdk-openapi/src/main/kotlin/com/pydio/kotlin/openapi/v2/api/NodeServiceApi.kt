/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.pydio.kotlin.openapi.v2.api

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import com.pydio.kotlin.openapi.v2.model.IdmSearchUserMetaRequest
import com.pydio.kotlin.openapi.v2.model.JobsCtrlCommand
import com.pydio.kotlin.openapi.v2.model.RestActionParameters
import com.pydio.kotlin.openapi.v2.model.RestBackgroundAction
import com.pydio.kotlin.openapi.v2.model.RestBatchUpdateMetaList
import com.pydio.kotlin.openapi.v2.model.RestCreateCheckRequest
import com.pydio.kotlin.openapi.v2.model.RestCreateCheckResponse
import com.pydio.kotlin.openapi.v2.model.RestCreateRequest
import com.pydio.kotlin.openapi.v2.model.RestError
import com.pydio.kotlin.openapi.v2.model.RestListTemplatesResponse
import com.pydio.kotlin.openapi.v2.model.RestLookupRequest
import com.pydio.kotlin.openapi.v2.model.RestNamespaceValuesOperation
import com.pydio.kotlin.openapi.v2.model.RestNamespaceValuesResponse
import com.pydio.kotlin.openapi.v2.model.RestNode
import com.pydio.kotlin.openapi.v2.model.RestNodeCollection
import com.pydio.kotlin.openapi.v2.model.RestNodeUpdates
import com.pydio.kotlin.openapi.v2.model.RestPerformActionResponse
import com.pydio.kotlin.openapi.v2.model.RestPublicLinkDeleteSuccess
import com.pydio.kotlin.openapi.v2.model.RestPublicLinkRequest
import com.pydio.kotlin.openapi.v2.model.RestSelection
import com.pydio.kotlin.openapi.v2.model.RestShareLink
import com.pydio.kotlin.openapi.v2.model.RestUserMetaList
import com.pydio.kotlin.openapi.v2.model.RestUserMetaNamespaceCollection

import com.squareup.moshi.Json

import com.pydio.kotlin.openapi.v2.infrastructure.ApiClient
import com.pydio.kotlin.openapi.v2.infrastructure.ApiResponse
import com.pydio.kotlin.openapi.v2.infrastructure.ClientException
import com.pydio.kotlin.openapi.v2.infrastructure.ClientError
import com.pydio.kotlin.openapi.v2.infrastructure.ServerException
import com.pydio.kotlin.openapi.v2.infrastructure.ServerError
import com.pydio.kotlin.openapi.v2.infrastructure.MultiValueMap
import com.pydio.kotlin.openapi.v2.infrastructure.PartConfig
import com.pydio.kotlin.openapi.v2.infrastructure.RequestConfig
import com.pydio.kotlin.openapi.v2.infrastructure.RequestMethod
import com.pydio.kotlin.openapi.v2.infrastructure.ResponseType
import com.pydio.kotlin.openapi.v2.infrastructure.Success
import com.pydio.kotlin.openapi.v2.infrastructure.toMultiValue

class NodeServiceApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * enum for parameter name
     */
     enum class NameBackgroundActionInfo(val value: kotlin.String) {
         @Json(name = "delete") delete("delete"),
         @Json(name = "restore") restore("restore"),
         @Json(name = "copy") copy("copy"),
         @Json(name = "move") move("move"),
         @Json(name = "extract") extract("extract"),
         @Json(name = "compress") compress("compress");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Retrieve information about an action running in background
     * 
     * @param name 
     * @param jobUuid 
     * @return RestBackgroundAction
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun backgroundActionInfo(name: NameBackgroundActionInfo, jobUuid: kotlin.String) : RestBackgroundAction {
        val localVarResponse = backgroundActionInfoWithHttpInfo(name = name, jobUuid = jobUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestBackgroundAction
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve information about an action running in background
     * 
     * @param name 
     * @param jobUuid 
     * @return ApiResponse<RestBackgroundAction?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun backgroundActionInfoWithHttpInfo(name: NameBackgroundActionInfo, jobUuid: kotlin.String) : ApiResponse<RestBackgroundAction?> {
        val localVariableConfig = backgroundActionInfoRequestConfig(name = name, jobUuid = jobUuid)

        return request<Unit, RestBackgroundAction>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation backgroundActionInfo
     *
     * @param name 
     * @param jobUuid 
     * @return RequestConfig
     */
    fun backgroundActionInfoRequestConfig(name: NameBackgroundActionInfo, jobUuid: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/n/action/{Name}/{JobUuid}".replace("{"+"Name"+"}", encodeURIComponent(name.value.toString())).replace("{"+"JobUuid"+"}", encodeURIComponent(jobUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update/delete user meta in batch. Passed UserMetas must contain a NodeUuid
     * 
     * @param body 
     * @return RestBatchUpdateMetaList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun batchUpdateMeta(body: RestBatchUpdateMetaList) : RestBatchUpdateMetaList {
        val localVarResponse = batchUpdateMetaWithHttpInfo(body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestBatchUpdateMetaList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update/delete user meta in batch. Passed UserMetas must contain a NodeUuid
     * 
     * @param body 
     * @return ApiResponse<RestBatchUpdateMetaList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun batchUpdateMetaWithHttpInfo(body: RestBatchUpdateMetaList) : ApiResponse<RestBatchUpdateMetaList?> {
        val localVariableConfig = batchUpdateMetaRequestConfig(body = body)

        return request<RestBatchUpdateMetaList, RestBatchUpdateMetaList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation batchUpdateMeta
     *
     * @param body 
     * @return RequestConfig
     */
    fun batchUpdateMetaRequestConfig(body: RestBatchUpdateMetaList) : RequestConfig<RestBatchUpdateMetaList> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/n/meta/batch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter name
     */
     enum class NameControlBackgroundAction(val value: kotlin.String) {
         @Json(name = "delete") delete("delete"),
         @Json(name = "restore") restore("restore"),
         @Json(name = "copy") copy("copy"),
         @Json(name = "move") move("move"),
         @Json(name = "extract") extract("extract"),
         @Json(name = "compress") compress("compress");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Send control commands to a background job
     * 
     * @param name 
     * @param jobUuid 
     * @param command 
     * @return RestBackgroundAction
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun controlBackgroundAction(name: NameControlBackgroundAction, jobUuid: kotlin.String, command: JobsCtrlCommand) : RestBackgroundAction {
        val localVarResponse = controlBackgroundActionWithHttpInfo(name = name, jobUuid = jobUuid, command = command)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestBackgroundAction
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Send control commands to a background job
     * 
     * @param name 
     * @param jobUuid 
     * @param command 
     * @return ApiResponse<RestBackgroundAction?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun controlBackgroundActionWithHttpInfo(name: NameControlBackgroundAction, jobUuid: kotlin.String, command: JobsCtrlCommand) : ApiResponse<RestBackgroundAction?> {
        val localVariableConfig = controlBackgroundActionRequestConfig(name = name, jobUuid = jobUuid, command = command)

        return request<JobsCtrlCommand, RestBackgroundAction>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation controlBackgroundAction
     *
     * @param name 
     * @param jobUuid 
     * @param command 
     * @return RequestConfig
     */
    fun controlBackgroundActionRequestConfig(name: NameControlBackgroundAction, jobUuid: kotlin.String, command: JobsCtrlCommand) : RequestConfig<JobsCtrlCommand> {
        val localVariableBody = command
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/n/action/{Name}/{JobUuid}".replace("{"+"Name"+"}", encodeURIComponent(name.value.toString())).replace("{"+"JobUuid"+"}", encodeURIComponent(jobUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create one or many files (empty or hydrated from a TemplateUuid) or folders
     * 
     * @param body 
     * @return RestNodeCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun create(body: RestCreateRequest) : RestNodeCollection {
        val localVarResponse = createWithHttpInfo(body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestNodeCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create one or many files (empty or hydrated from a TemplateUuid) or folders
     * 
     * @param body 
     * @return ApiResponse<RestNodeCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createWithHttpInfo(body: RestCreateRequest) : ApiResponse<RestNodeCollection?> {
        val localVariableConfig = createRequestConfig(body = body)

        return request<RestCreateRequest, RestNodeCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation create
     *
     * @param body 
     * @return RequestConfig
     */
    fun createRequestConfig(body: RestCreateRequest) : RequestConfig<RestCreateRequest> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/n/nodes/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Apply some pre-validation checks on node name before sending an upload
     * 
     * @param body Request for pre-checking nodes before uploading or creating them.
     * @return RestCreateCheckResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createCheck(body: RestCreateCheckRequest) : RestCreateCheckResponse {
        val localVarResponse = createCheckWithHttpInfo(body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestCreateCheckResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Apply some pre-validation checks on node name before sending an upload
     * 
     * @param body Request for pre-checking nodes before uploading or creating them.
     * @return ApiResponse<RestCreateCheckResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createCheckWithHttpInfo(body: RestCreateCheckRequest) : ApiResponse<RestCreateCheckResponse?> {
        val localVariableConfig = createCheckRequestConfig(body = body)

        return request<RestCreateCheckRequest, RestCreateCheckResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createCheck
     *
     * @param body Request for pre-checking nodes before uploading or creating them.
     * @return RequestConfig
     */
    fun createCheckRequestConfig(body: RestCreateCheckRequest) : RequestConfig<RestCreateCheckRequest> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/n/nodes/create/precheck",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create a public link on a given node
     * 
     * @param uuid 
     * @param publicLinkRequest 
     * @return RestShareLink
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createPublicLink(uuid: kotlin.String, publicLinkRequest: RestPublicLinkRequest) : RestShareLink {
        val localVarResponse = createPublicLinkWithHttpInfo(uuid = uuid, publicLinkRequest = publicLinkRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestShareLink
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create a public link on a given node
     * 
     * @param uuid 
     * @param publicLinkRequest 
     * @return ApiResponse<RestShareLink?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createPublicLinkWithHttpInfo(uuid: kotlin.String, publicLinkRequest: RestPublicLinkRequest) : ApiResponse<RestShareLink?> {
        val localVariableConfig = createPublicLinkRequestConfig(uuid = uuid, publicLinkRequest = publicLinkRequest)

        return request<RestPublicLinkRequest, RestShareLink>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createPublicLink
     *
     * @param uuid 
     * @param publicLinkRequest 
     * @return RequestConfig
     */
    fun createPublicLinkRequestConfig(uuid: kotlin.String, publicLinkRequest: RestPublicLinkRequest) : RequestConfig<RestPublicLinkRequest> {
        val localVariableBody = publicLinkRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/n/node/{Uuid}/link".replace("{"+"Uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create and persist a temporary selection of nodes, that can be used by other actions
     * 
     * @param body Request to create a selection from a list of nodes.
     * @return RestSelection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createSelection(body: RestSelection) : RestSelection {
        val localVarResponse = createSelectionWithHttpInfo(body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestSelection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create and persist a temporary selection of nodes, that can be used by other actions
     * 
     * @param body Request to create a selection from a list of nodes.
     * @return ApiResponse<RestSelection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createSelectionWithHttpInfo(body: RestSelection) : ApiResponse<RestSelection?> {
        val localVariableConfig = createSelectionRequestConfig(body = body)

        return request<RestSelection, RestSelection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createSelection
     *
     * @param body Request to create a selection from a list of nodes.
     * @return RequestConfig
     */
    fun createSelectionRequestConfig(body: RestSelection) : RequestConfig<RestSelection> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/n/selection",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Remove a public link
     * 
     * @param linkUuid 
     * @return RestPublicLinkDeleteSuccess
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deletePublicLink(linkUuid: kotlin.String) : RestPublicLinkDeleteSuccess {
        val localVarResponse = deletePublicLinkWithHttpInfo(linkUuid = linkUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestPublicLinkDeleteSuccess
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Remove a public link
     * 
     * @param linkUuid 
     * @return ApiResponse<RestPublicLinkDeleteSuccess?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deletePublicLinkWithHttpInfo(linkUuid: kotlin.String) : ApiResponse<RestPublicLinkDeleteSuccess?> {
        val localVariableConfig = deletePublicLinkRequestConfig(linkUuid = linkUuid)

        return request<Unit, RestPublicLinkDeleteSuccess>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deletePublicLink
     *
     * @param linkUuid 
     * @return RequestConfig
     */
    fun deletePublicLinkRequestConfig(linkUuid: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/n/link/{LinkUuid}".replace("{"+"LinkUuid"+"}", encodeURIComponent(linkUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Load a node by its Uuid
     * 
     * @param uuid 
     * @param path  (optional)
     * @return RestNode
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getByUuid(uuid: kotlin.String, path: kotlin.String? = null) : RestNode {
        val localVarResponse = getByUuidWithHttpInfo(uuid = uuid, path = path)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestNode
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Load a node by its Uuid
     * 
     * @param uuid 
     * @param path  (optional)
     * @return ApiResponse<RestNode?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getByUuidWithHttpInfo(uuid: kotlin.String, path: kotlin.String?) : ApiResponse<RestNode?> {
        val localVariableConfig = getByUuidRequestConfig(uuid = uuid, path = path)

        return request<Unit, RestNode>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getByUuid
     *
     * @param uuid 
     * @param path  (optional)
     * @return RequestConfig
     */
    fun getByUuidRequestConfig(uuid: kotlin.String, path: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (path != null) {
                    put("Path", listOf(path.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/n/node/{Uuid}".replace("{"+"Uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Load public link information by Uuid
     * 
     * @param linkUuid 
     * @return RestShareLink
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPublicLink(linkUuid: kotlin.String) : RestShareLink {
        val localVarResponse = getPublicLinkWithHttpInfo(linkUuid = linkUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestShareLink
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Load public link information by Uuid
     * 
     * @param linkUuid 
     * @return ApiResponse<RestShareLink?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPublicLinkWithHttpInfo(linkUuid: kotlin.String) : ApiResponse<RestShareLink?> {
        val localVariableConfig = getPublicLinkRequestConfig(linkUuid = linkUuid)

        return request<Unit, RestShareLink>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPublicLink
     *
     * @param linkUuid 
     * @return RequestConfig
     */
    fun getPublicLinkRequestConfig(linkUuid: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/n/link/{LinkUuid}".replace("{"+"LinkUuid"+"}", encodeURIComponent(linkUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter operationOperation
     */
     enum class OperationOperationListNamespaceValues(val value: kotlin.String) {
         @Json(name = "PUT") PUT("PUT"),
         @Json(name = "DELETE") DELETE("DELETE");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * List values for a given namespace
     * 
     * @param namespace List persisted values for this namespace
     * @param operationOperation  (default to PUT)
     * @param operationValues 
     * @return RestNamespaceValuesResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listNamespaceValues(namespace: kotlin.String, operationOperation: OperationOperationListNamespaceValues = OperationOperationListNamespaceValues.PUT, operationValues: kotlin.collections.List<kotlin.String>) : RestNamespaceValuesResponse {
        val localVarResponse = listNamespaceValuesWithHttpInfo(namespace = namespace, operationOperation = operationOperation, operationValues = operationValues)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestNamespaceValuesResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List values for a given namespace
     * 
     * @param namespace List persisted values for this namespace
     * @param operationOperation  (default to PUT)
     * @param operationValues 
     * @return ApiResponse<RestNamespaceValuesResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listNamespaceValuesWithHttpInfo(namespace: kotlin.String, operationOperation: OperationOperationListNamespaceValues, operationValues: kotlin.collections.List<kotlin.String>) : ApiResponse<RestNamespaceValuesResponse?> {
        val localVariableConfig = listNamespaceValuesRequestConfig(namespace = namespace, operationOperation = operationOperation, operationValues = operationValues)

        return request<Unit, RestNamespaceValuesResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listNamespaceValues
     *
     * @param namespace List persisted values for this namespace
     * @param operationOperation  (default to PUT)
     * @param operationValues 
     * @return RequestConfig
     */
    fun listNamespaceValuesRequestConfig(namespace: kotlin.String, operationOperation: OperationOperationListNamespaceValues, operationValues: kotlin.collections.List<kotlin.String>) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("Operation.Operation", listOf(operationOperation.value))
                put("Operation.Values", toMultiValue(operationValues.toList(), "multi"))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/n/meta/namespace/{Namespace}".replace("{"+"Namespace"+"}", encodeURIComponent(namespace.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * List defined meta namespaces
     * 
     * @return RestUserMetaNamespaceCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listNamespaces() : RestUserMetaNamespaceCollection {
        val localVarResponse = listNamespacesWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestUserMetaNamespaceCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List defined meta namespaces
     * 
     * @return ApiResponse<RestUserMetaNamespaceCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listNamespacesWithHttpInfo() : ApiResponse<RestUserMetaNamespaceCollection?> {
        val localVariableConfig = listNamespacesRequestConfig()

        return request<Unit, RestUserMetaNamespaceCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listNamespaces
     *
     * @return RequestConfig
     */
    fun listNamespacesRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/n/meta/namespace",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * List all known versions of a node
     * 
     * @param uuid 
     * @param path  (optional)
     * @return RestNodeCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listVersions(uuid: kotlin.String, path: kotlin.String? = null) : RestNodeCollection {
        val localVarResponse = listVersionsWithHttpInfo(uuid = uuid, path = path)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestNodeCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List all known versions of a node
     * 
     * @param uuid 
     * @param path  (optional)
     * @return ApiResponse<RestNodeCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listVersionsWithHttpInfo(uuid: kotlin.String, path: kotlin.String?) : ApiResponse<RestNodeCollection?> {
        val localVariableConfig = listVersionsRequestConfig(uuid = uuid, path = path)

        return request<Unit, RestNodeCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listVersions
     *
     * @param uuid 
     * @param path  (optional)
     * @return RequestConfig
     */
    fun listVersionsRequestConfig(uuid: kotlin.String, path: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (path != null) {
                    put("Path", listOf(path.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/n/node/{Uuid}/versions".replace("{"+"Uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Generic request to either list (using Locators) or search (using Query) for nodes
     * 
     * @param body 
     * @return RestNodeCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun lookup(body: RestLookupRequest) : RestNodeCollection {
        val localVarResponse = lookupWithHttpInfo(body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestNodeCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Generic request to either list (using Locators) or search (using Query) for nodes
     * 
     * @param body 
     * @return ApiResponse<RestNodeCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun lookupWithHttpInfo(body: RestLookupRequest) : ApiResponse<RestNodeCollection?> {
        val localVariableConfig = lookupRequestConfig(body = body)

        return request<RestLookupRequest, RestNodeCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation lookup
     *
     * @param body 
     * @return RequestConfig
     */
    fun lookupRequestConfig(body: RestLookupRequest) : RequestConfig<RestLookupRequest> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/n/nodes",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * PatchNode is used to update a node specific meta. It is used for reserved meta as well (bookmarks, contentLock)
     * 
     * @param uuid 
     * @param nodeUpdates 
     * @return RestNode
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun patchNode(uuid: kotlin.String, nodeUpdates: RestNodeUpdates) : RestNode {
        val localVarResponse = patchNodeWithHttpInfo(uuid = uuid, nodeUpdates = nodeUpdates)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestNode
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PatchNode is used to update a node specific meta. It is used for reserved meta as well (bookmarks, contentLock)
     * 
     * @param uuid 
     * @param nodeUpdates 
     * @return ApiResponse<RestNode?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun patchNodeWithHttpInfo(uuid: kotlin.String, nodeUpdates: RestNodeUpdates) : ApiResponse<RestNode?> {
        val localVariableConfig = patchNodeRequestConfig(uuid = uuid, nodeUpdates = nodeUpdates)

        return request<RestNodeUpdates, RestNode>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation patchNode
     *
     * @param uuid 
     * @param nodeUpdates 
     * @return RequestConfig
     */
    fun patchNodeRequestConfig(uuid: kotlin.String, nodeUpdates: RestNodeUpdates) : RequestConfig<RestNodeUpdates> {
        val localVariableBody = nodeUpdates
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/n/node/{Uuid}".replace("{"+"Uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter name
     */
     enum class NamePerformAction(val value: kotlin.String) {
         @Json(name = "delete") delete("delete"),
         @Json(name = "restore") restore("restore"),
         @Json(name = "copy") copy("copy"),
         @Json(name = "move") move("move"),
         @Json(name = "extract") extract("extract"),
         @Json(name = "compress") compress("compress");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Trigger an action on the tree. Returns a JobInfo describing a background task.
     * 
     * @param name 
     * @param parameters 
     * @param jobUuid  (optional)
     * @return RestPerformActionResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun performAction(name: NamePerformAction, parameters: RestActionParameters, jobUuid: kotlin.String? = null) : RestPerformActionResponse {
        val localVarResponse = performActionWithHttpInfo(name = name, parameters = parameters, jobUuid = jobUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestPerformActionResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Trigger an action on the tree. Returns a JobInfo describing a background task.
     * 
     * @param name 
     * @param parameters 
     * @param jobUuid  (optional)
     * @return ApiResponse<RestPerformActionResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun performActionWithHttpInfo(name: NamePerformAction, parameters: RestActionParameters, jobUuid: kotlin.String?) : ApiResponse<RestPerformActionResponse?> {
        val localVariableConfig = performActionRequestConfig(name = name, parameters = parameters, jobUuid = jobUuid)

        return request<RestActionParameters, RestPerformActionResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation performAction
     *
     * @param name 
     * @param parameters 
     * @param jobUuid  (optional)
     * @return RequestConfig
     */
    fun performActionRequestConfig(name: NamePerformAction, parameters: RestActionParameters, jobUuid: kotlin.String?) : RequestConfig<RestActionParameters> {
        val localVariableBody = parameters
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (jobUuid != null) {
                    put("JobUuid", listOf(jobUuid.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/n/action/{Name}".replace("{"+"Name"+"}", encodeURIComponent(name.value.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Search a list of meta by node Id or by User id and by namespace
     * 
     * @param body 
     * @return RestUserMetaList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchMeta(body: IdmSearchUserMetaRequest) : RestUserMetaList {
        val localVarResponse = searchMetaWithHttpInfo(body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestUserMetaList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Search a list of meta by node Id or by User id and by namespace
     * 
     * @param body 
     * @return ApiResponse<RestUserMetaList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchMetaWithHttpInfo(body: IdmSearchUserMetaRequest) : ApiResponse<RestUserMetaList?> {
        val localVariableConfig = searchMetaRequestConfig(body = body)

        return request<IdmSearchUserMetaRequest, RestUserMetaList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchMeta
     *
     * @param body 
     * @return RequestConfig
     */
    fun searchMetaRequestConfig(body: IdmSearchUserMetaRequest) : RequestConfig<IdmSearchUserMetaRequest> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/n/meta/find",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * List available templates for hydrating empty files
     * 
     * @param templateType  (optional)
     * @return RestListTemplatesResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templates(templateType: kotlin.String? = null) : RestListTemplatesResponse {
        val localVarResponse = templatesWithHttpInfo(templateType = templateType)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestListTemplatesResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List available templates for hydrating empty files
     * 
     * @param templateType  (optional)
     * @return ApiResponse<RestListTemplatesResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templatesWithHttpInfo(templateType: kotlin.String?) : ApiResponse<RestListTemplatesResponse?> {
        val localVariableConfig = templatesRequestConfig(templateType = templateType)

        return request<Unit, RestListTemplatesResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templates
     *
     * @param templateType  (optional)
     * @return RequestConfig
     */
    fun templatesRequestConfig(templateType: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (templateType != null) {
                    put("TemplateType", listOf(templateType.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/n/templates",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Add/delete a values for a given namespace
     * 
     * @param namespace List persisted values for this namespace
     * @param operation 
     * @return RestNamespaceValuesResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateNamespaceValues(namespace: kotlin.String, operation: RestNamespaceValuesOperation) : RestNamespaceValuesResponse {
        val localVarResponse = updateNamespaceValuesWithHttpInfo(namespace = namespace, operation = operation)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestNamespaceValuesResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Add/delete a values for a given namespace
     * 
     * @param namespace List persisted values for this namespace
     * @param operation 
     * @return ApiResponse<RestNamespaceValuesResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateNamespaceValuesWithHttpInfo(namespace: kotlin.String, operation: RestNamespaceValuesOperation) : ApiResponse<RestNamespaceValuesResponse?> {
        val localVariableConfig = updateNamespaceValuesRequestConfig(namespace = namespace, operation = operation)

        return request<RestNamespaceValuesOperation, RestNamespaceValuesResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateNamespaceValues
     *
     * @param namespace List persisted values for this namespace
     * @param operation 
     * @return RequestConfig
     */
    fun updateNamespaceValuesRequestConfig(namespace: kotlin.String, operation: RestNamespaceValuesOperation) : RequestConfig<RestNamespaceValuesOperation> {
        val localVariableBody = operation
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/n/meta/namespace/{Namespace}".replace("{"+"Namespace"+"}", encodeURIComponent(namespace.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update public link settings
     * 
     * @param linkUuid 
     * @param publicLinkRequest 
     * @return RestShareLink
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updatePublicLink(linkUuid: kotlin.String, publicLinkRequest: RestPublicLinkRequest) : RestShareLink {
        val localVarResponse = updatePublicLinkWithHttpInfo(linkUuid = linkUuid, publicLinkRequest = publicLinkRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestShareLink
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update public link settings
     * 
     * @param linkUuid 
     * @param publicLinkRequest 
     * @return ApiResponse<RestShareLink?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updatePublicLinkWithHttpInfo(linkUuid: kotlin.String, publicLinkRequest: RestPublicLinkRequest) : ApiResponse<RestShareLink?> {
        val localVariableConfig = updatePublicLinkRequestConfig(linkUuid = linkUuid, publicLinkRequest = publicLinkRequest)

        return request<RestPublicLinkRequest, RestShareLink>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updatePublicLink
     *
     * @param linkUuid 
     * @param publicLinkRequest 
     * @return RequestConfig
     */
    fun updatePublicLinkRequestConfig(linkUuid: kotlin.String, publicLinkRequest: RestPublicLinkRequest) : RequestConfig<RestPublicLinkRequest> {
        val localVariableBody = publicLinkRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/n/link/{LinkUuid}".replace("{"+"LinkUuid"+"}", encodeURIComponent(linkUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Special API for Bookmarks, will load userMeta and the associated nodes, and return as a node list
     * 
     * @param all  (optional)
     * @return RestNodeCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userBookmarks(all: kotlin.Boolean? = null) : RestNodeCollection {
        val localVarResponse = userBookmarksWithHttpInfo(all = all)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestNodeCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Special API for Bookmarks, will load userMeta and the associated nodes, and return as a node list
     * 
     * @param all  (optional)
     * @return ApiResponse<RestNodeCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun userBookmarksWithHttpInfo(all: kotlin.Boolean?) : ApiResponse<RestNodeCollection?> {
        val localVariableConfig = userBookmarksRequestConfig(all = all)

        return request<Unit, RestNodeCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation userBookmarks
     *
     * @param all  (optional)
     * @return RequestConfig
     */
    fun userBookmarksRequestConfig(all: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (all != null) {
                    put("All", listOf(all.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/n/nodes/bookmarks",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}

/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.pydio.kotlin.openapi.api

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import com.pydio.kotlin.openapi.model.IdmSearchUserMetaRequest
import com.pydio.kotlin.openapi.model.JobsCtrlCommand
import com.pydio.kotlin.openapi.model.JobsJob
import com.pydio.kotlin.openapi.model.RestActionParameters
import com.pydio.kotlin.openapi.model.RestActionResponse
import com.pydio.kotlin.openapi.model.RestBatchUpdateMetaList
import com.pydio.kotlin.openapi.model.RestCreateRequest
import com.pydio.kotlin.openapi.model.RestError
import com.pydio.kotlin.openapi.model.RestListTemplatesResponse
import com.pydio.kotlin.openapi.model.RestLookupRequest
import com.pydio.kotlin.openapi.model.RestNamespaceValuesOperation
import com.pydio.kotlin.openapi.model.RestNamespaceValuesResponse
import com.pydio.kotlin.openapi.model.RestNode
import com.pydio.kotlin.openapi.model.RestNodeCollection
import com.pydio.kotlin.openapi.model.RestNodeUpdates
import com.pydio.kotlin.openapi.model.RestPublicLinkDeleteSuccess
import com.pydio.kotlin.openapi.model.RestSelection
import com.pydio.kotlin.openapi.model.RestShareLink
import com.pydio.kotlin.openapi.model.RestUpsertPublicLinkRequest
import com.pydio.kotlin.openapi.model.RestUserMetaList
import com.pydio.kotlin.openapi.model.RestUserMetaNamespaceCollection

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class NodeServiceApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * Update/delete user meta in batch. Passed UserMetas must contain a NodeUuid
     * 
     * @param body 
     * @return RestBatchUpdateMetaList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun batchUpdateMeta(body: RestBatchUpdateMetaList) : RestBatchUpdateMetaList {
        val localVarResponse = batchUpdateMetaWithHttpInfo(body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestBatchUpdateMetaList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update/delete user meta in batch. Passed UserMetas must contain a NodeUuid
     * 
     * @param body 
     * @return ApiResponse<RestBatchUpdateMetaList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun batchUpdateMetaWithHttpInfo(body: RestBatchUpdateMetaList) : ApiResponse<RestBatchUpdateMetaList?> {
        val localVariableConfig = batchUpdateMetaRequestConfig(body = body)

        return request<RestBatchUpdateMetaList, RestBatchUpdateMetaList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation batchUpdateMeta
     *
     * @param body 
     * @return RequestConfig
     */
    fun batchUpdateMetaRequestConfig(body: RestBatchUpdateMetaList) : RequestConfig<RestBatchUpdateMetaList> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/node/meta/batch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter name
     */
     enum class NameControlActionJob(val value: kotlin.String) {
         @Json(name = "delete") delete("delete"),
         @Json(name = "restore") restore("restore"),
         @Json(name = "copy") copy("copy"),
         @Json(name = "move") move("move"),
         @Json(name = "extract") extract("extract"),
         @Json(name = "compress") compress("compress");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Send control commands to a background job
     * 
     * @param name 
     * @param jobUuid 
     * @param command 
     * @return JobsJob
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun controlActionJob(name: NameControlActionJob, jobUuid: kotlin.String, command: JobsCtrlCommand) : JobsJob {
        val localVarResponse = controlActionJobWithHttpInfo(name = name, jobUuid = jobUuid, command = command)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JobsJob
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Send control commands to a background job
     * 
     * @param name 
     * @param jobUuid 
     * @param command 
     * @return ApiResponse<JobsJob?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun controlActionJobWithHttpInfo(name: NameControlActionJob, jobUuid: kotlin.String, command: JobsCtrlCommand) : ApiResponse<JobsJob?> {
        val localVariableConfig = controlActionJobRequestConfig(name = name, jobUuid = jobUuid, command = command)

        return request<JobsCtrlCommand, JobsJob>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation controlActionJob
     *
     * @param name 
     * @param jobUuid 
     * @param command 
     * @return RequestConfig
     */
    fun controlActionJobRequestConfig(name: NameControlActionJob, jobUuid: kotlin.String, command: JobsCtrlCommand) : RequestConfig<JobsCtrlCommand> {
        val localVariableBody = command
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/node/action/{Name}/{JobUuid}".replace("{"+"Name"+"}", encodeURIComponent(name.value.toString())).replace("{"+"JobUuid"+"}", encodeURIComponent(jobUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Create one or many files (empty or hydrated from a TemplateUuid) or folders
     * 
     * @param body 
     * @return RestNodeCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun create(body: RestCreateRequest) : RestNodeCollection {
        val localVarResponse = createWithHttpInfo(body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestNodeCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create one or many files (empty or hydrated from a TemplateUuid) or folders
     * 
     * @param body 
     * @return ApiResponse<RestNodeCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createWithHttpInfo(body: RestCreateRequest) : ApiResponse<RestNodeCollection?> {
        val localVariableConfig = createRequestConfig(body = body)

        return request<RestCreateRequest, RestNodeCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation create
     *
     * @param body 
     * @return RequestConfig
     */
    fun createRequestConfig(body: RestCreateRequest) : RequestConfig<RestCreateRequest> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/node/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Create a public link on a given node
     * 
     * @param body 
     * @return RestShareLink
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createPublicLink(body: RestUpsertPublicLinkRequest) : RestShareLink {
        val localVarResponse = createPublicLinkWithHttpInfo(body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestShareLink
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create a public link on a given node
     * 
     * @param body 
     * @return ApiResponse<RestShareLink?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createPublicLinkWithHttpInfo(body: RestUpsertPublicLinkRequest) : ApiResponse<RestShareLink?> {
        val localVariableConfig = createPublicLinkRequestConfig(body = body)

        return request<RestUpsertPublicLinkRequest, RestShareLink>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createPublicLink
     *
     * @param body 
     * @return RequestConfig
     */
    fun createPublicLinkRequestConfig(body: RestUpsertPublicLinkRequest) : RequestConfig<RestUpsertPublicLinkRequest> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/node/link",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Create and persist a temporary selection of nodes, that can be used by other actions
     * 
     * @param body Request to create a selection from a list of nodes.
     * @return RestSelection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createSelection(body: RestSelection) : RestSelection {
        val localVarResponse = createSelectionWithHttpInfo(body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestSelection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create and persist a temporary selection of nodes, that can be used by other actions
     * 
     * @param body Request to create a selection from a list of nodes.
     * @return ApiResponse<RestSelection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createSelectionWithHttpInfo(body: RestSelection) : ApiResponse<RestSelection?> {
        val localVariableConfig = createSelectionRequestConfig(body = body)

        return request<RestSelection, RestSelection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createSelection
     *
     * @param body Request to create a selection from a list of nodes.
     * @return RequestConfig
     */
    fun createSelectionRequestConfig(body: RestSelection) : RequestConfig<RestSelection> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/node/selection",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Remove a public link
     * 
     * @param uuid 
     * @return RestPublicLinkDeleteSuccess
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deletePublicLink(uuid: kotlin.String) : RestPublicLinkDeleteSuccess {
        val localVarResponse = deletePublicLinkWithHttpInfo(uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestPublicLinkDeleteSuccess
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Remove a public link
     * 
     * @param uuid 
     * @return ApiResponse<RestPublicLinkDeleteSuccess?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deletePublicLinkWithHttpInfo(uuid: kotlin.String) : ApiResponse<RestPublicLinkDeleteSuccess?> {
        val localVariableConfig = deletePublicLinkRequestConfig(uuid = uuid)

        return request<Unit, RestPublicLinkDeleteSuccess>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deletePublicLink
     *
     * @param uuid 
     * @return RequestConfig
     */
    fun deletePublicLinkRequestConfig(uuid: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/node/link/{Uuid}".replace("{"+"Uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter name
     */
     enum class NameGetActionJob(val value: kotlin.String) {
         @Json(name = "delete") delete("delete"),
         @Json(name = "restore") restore("restore"),
         @Json(name = "copy") copy("copy"),
         @Json(name = "move") move("move"),
         @Json(name = "extract") extract("extract"),
         @Json(name = "compress") compress("compress");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Retrieve information about an action running in background
     * 
     * @param name 
     * @param jobUuid 
     * @param parametersTargetNodeUuid  (optional)
     * @param parametersTargetNodePath  (optional)
     * @param parametersSelectionUuid  (optional)
     * @param parametersJsonParameters  (optional)
     * @param parametersAwait  (optional)
     * @return JobsJob
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getActionJob(name: NameGetActionJob, jobUuid: kotlin.String, parametersTargetNodeUuid: kotlin.String? = null, parametersTargetNodePath: kotlin.String? = null, parametersSelectionUuid: kotlin.String? = null, parametersJsonParameters: kotlin.String? = null, parametersAwait: kotlin.Boolean? = null) : JobsJob {
        val localVarResponse = getActionJobWithHttpInfo(name = name, jobUuid = jobUuid, parametersTargetNodeUuid = parametersTargetNodeUuid, parametersTargetNodePath = parametersTargetNodePath, parametersSelectionUuid = parametersSelectionUuid, parametersJsonParameters = parametersJsonParameters, parametersAwait = parametersAwait)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JobsJob
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve information about an action running in background
     * 
     * @param name 
     * @param jobUuid 
     * @param parametersTargetNodeUuid  (optional)
     * @param parametersTargetNodePath  (optional)
     * @param parametersSelectionUuid  (optional)
     * @param parametersJsonParameters  (optional)
     * @param parametersAwait  (optional)
     * @return ApiResponse<JobsJob?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getActionJobWithHttpInfo(name: NameGetActionJob, jobUuid: kotlin.String, parametersTargetNodeUuid: kotlin.String?, parametersTargetNodePath: kotlin.String?, parametersSelectionUuid: kotlin.String?, parametersJsonParameters: kotlin.String?, parametersAwait: kotlin.Boolean?) : ApiResponse<JobsJob?> {
        val localVariableConfig = getActionJobRequestConfig(name = name, jobUuid = jobUuid, parametersTargetNodeUuid = parametersTargetNodeUuid, parametersTargetNodePath = parametersTargetNodePath, parametersSelectionUuid = parametersSelectionUuid, parametersJsonParameters = parametersJsonParameters, parametersAwait = parametersAwait)

        return request<Unit, JobsJob>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getActionJob
     *
     * @param name 
     * @param jobUuid 
     * @param parametersTargetNodeUuid  (optional)
     * @param parametersTargetNodePath  (optional)
     * @param parametersSelectionUuid  (optional)
     * @param parametersJsonParameters  (optional)
     * @param parametersAwait  (optional)
     * @return RequestConfig
     */
    fun getActionJobRequestConfig(name: NameGetActionJob, jobUuid: kotlin.String, parametersTargetNodeUuid: kotlin.String?, parametersTargetNodePath: kotlin.String?, parametersSelectionUuid: kotlin.String?, parametersJsonParameters: kotlin.String?, parametersAwait: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (parametersTargetNodeUuid != null) {
                    put("Parameters.TargetNode.Uuid", listOf(parametersTargetNodeUuid.toString()))
                }
                if (parametersTargetNodePath != null) {
                    put("Parameters.TargetNode.Path", listOf(parametersTargetNodePath.toString()))
                }
                if (parametersSelectionUuid != null) {
                    put("Parameters.SelectionUuid", listOf(parametersSelectionUuid.toString()))
                }
                if (parametersJsonParameters != null) {
                    put("Parameters.JsonParameters", listOf(parametersJsonParameters.toString()))
                }
                if (parametersAwait != null) {
                    put("Parameters.Await", listOf(parametersAwait.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/node/action/{Name}/{JobUuid}".replace("{"+"Name"+"}", encodeURIComponent(name.value.toString())).replace("{"+"JobUuid"+"}", encodeURIComponent(jobUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Load a node by its path
     * 
     * @param path 
     * @param uuid  (optional)
     * @return RestNode
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getByPath(path: kotlin.String, uuid: kotlin.String? = null) : RestNode {
        val localVarResponse = getByPathWithHttpInfo(path = path, uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestNode
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Load a node by its path
     * 
     * @param path 
     * @param uuid  (optional)
     * @return ApiResponse<RestNode?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getByPathWithHttpInfo(path: kotlin.String, uuid: kotlin.String?) : ApiResponse<RestNode?> {
        val localVariableConfig = getByPathRequestConfig(path = path, uuid = uuid)

        return request<Unit, RestNode>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getByPath
     *
     * @param path 
     * @param uuid  (optional)
     * @return RequestConfig
     */
    fun getByPathRequestConfig(path: kotlin.String, uuid: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (uuid != null) {
                    put("Uuid", listOf(uuid.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/node/p/{Path}".replace("{"+"Path"+"}", encodeURIComponent(path.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Load a node by its Uuid
     * 
     * @param uuid 
     * @param path  (optional)
     * @return RestNode
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getByUuid(uuid: kotlin.String, path: kotlin.String? = null) : RestNode {
        val localVarResponse = getByUuidWithHttpInfo(uuid = uuid, path = path)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestNode
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Load a node by its Uuid
     * 
     * @param uuid 
     * @param path  (optional)
     * @return ApiResponse<RestNode?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getByUuidWithHttpInfo(uuid: kotlin.String, path: kotlin.String?) : ApiResponse<RestNode?> {
        val localVariableConfig = getByUuidRequestConfig(uuid = uuid, path = path)

        return request<Unit, RestNode>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getByUuid
     *
     * @param uuid 
     * @param path  (optional)
     * @return RequestConfig
     */
    fun getByUuidRequestConfig(uuid: kotlin.String, path: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (path != null) {
                    put("Path", listOf(path.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/node/u/{Uuid}".replace("{"+"Uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Load public link information by Uuid
     * 
     * @param uuid 
     * @return RestShareLink
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPublicLink(uuid: kotlin.String) : RestShareLink {
        val localVarResponse = getPublicLinkWithHttpInfo(uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestShareLink
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Load public link information by Uuid
     * 
     * @param uuid 
     * @return ApiResponse<RestShareLink?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPublicLinkWithHttpInfo(uuid: kotlin.String) : ApiResponse<RestShareLink?> {
        val localVariableConfig = getPublicLinkRequestConfig(uuid = uuid)

        return request<Unit, RestShareLink>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPublicLink
     *
     * @param uuid 
     * @return RequestConfig
     */
    fun getPublicLinkRequestConfig(uuid: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/node/link/{Uuid}".replace("{"+"Uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter operationOperation
     */
     enum class OperationOperationListNamespaceValues(val value: kotlin.String) {
         @Json(name = "PUT") PUT("PUT"),
         @Json(name = "DELETE") DELETE("DELETE");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * List values for a given namespace
     * 
     * @param namespace List persisted values for this namespace
     * @param operationOperation  (optional, default to PUT)
     * @param operationValues  (optional)
     * @return RestNamespaceValuesResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listNamespaceValues(namespace: kotlin.String, operationOperation: OperationOperationListNamespaceValues? = OperationOperationListNamespaceValues.PUT, operationValues: kotlin.collections.List<kotlin.String>? = null) : RestNamespaceValuesResponse {
        val localVarResponse = listNamespaceValuesWithHttpInfo(namespace = namespace, operationOperation = operationOperation, operationValues = operationValues)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestNamespaceValuesResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List values for a given namespace
     * 
     * @param namespace List persisted values for this namespace
     * @param operationOperation  (optional, default to PUT)
     * @param operationValues  (optional)
     * @return ApiResponse<RestNamespaceValuesResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listNamespaceValuesWithHttpInfo(namespace: kotlin.String, operationOperation: OperationOperationListNamespaceValues?, operationValues: kotlin.collections.List<kotlin.String>?) : ApiResponse<RestNamespaceValuesResponse?> {
        val localVariableConfig = listNamespaceValuesRequestConfig(namespace = namespace, operationOperation = operationOperation, operationValues = operationValues)

        return request<Unit, RestNamespaceValuesResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listNamespaceValues
     *
     * @param namespace List persisted values for this namespace
     * @param operationOperation  (optional, default to PUT)
     * @param operationValues  (optional)
     * @return RequestConfig
     */
    fun listNamespaceValuesRequestConfig(namespace: kotlin.String, operationOperation: OperationOperationListNamespaceValues?, operationValues: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (operationOperation != null) {
                    put("Operation.Operation", listOf(operationOperation.value))
                }
                if (operationValues != null) {
                    put("Operation.Values", toMultiValue(operationValues.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/node/meta/namespace/{Namespace}".replace("{"+"Namespace"+"}", encodeURIComponent(namespace.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * List defined meta namespaces
     * 
     * @return RestUserMetaNamespaceCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listNamespaces() : RestUserMetaNamespaceCollection {
        val localVarResponse = listNamespacesWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestUserMetaNamespaceCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List defined meta namespaces
     * 
     * @return ApiResponse<RestUserMetaNamespaceCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listNamespacesWithHttpInfo() : ApiResponse<RestUserMetaNamespaceCollection?> {
        val localVariableConfig = listNamespacesRequestConfig()

        return request<Unit, RestUserMetaNamespaceCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listNamespaces
     *
     * @return RequestConfig
     */
    fun listNamespacesRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/node/meta/namespace",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * List all known versions of a node
     * 
     * @param uuid 
     * @param path  (optional)
     * @return RestNodeCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listVersions(uuid: kotlin.String, path: kotlin.String? = null) : RestNodeCollection {
        val localVarResponse = listVersionsWithHttpInfo(uuid = uuid, path = path)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestNodeCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List all known versions of a node
     * 
     * @param uuid 
     * @param path  (optional)
     * @return ApiResponse<RestNodeCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listVersionsWithHttpInfo(uuid: kotlin.String, path: kotlin.String?) : ApiResponse<RestNodeCollection?> {
        val localVariableConfig = listVersionsRequestConfig(uuid = uuid, path = path)

        return request<Unit, RestNodeCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listVersions
     *
     * @param uuid 
     * @param path  (optional)
     * @return RequestConfig
     */
    fun listVersionsRequestConfig(uuid: kotlin.String, path: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (path != null) {
                    put("Path", listOf(path.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/node/v/{Uuid}".replace("{"+"Uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Generic request to either list (using Locators) or search (using Query) for nodes
     * 
     * @param body 
     * @return RestNodeCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun lookup(body: RestLookupRequest) : RestNodeCollection {
        val localVarResponse = lookupWithHttpInfo(body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestNodeCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Generic request to either list (using Locators) or search (using Query) for nodes
     * 
     * @param body 
     * @return ApiResponse<RestNodeCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun lookupWithHttpInfo(body: RestLookupRequest) : ApiResponse<RestNodeCollection?> {
        val localVariableConfig = lookupRequestConfig(body = body)

        return request<RestLookupRequest, RestNodeCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation lookup
     *
     * @param body 
     * @return RequestConfig
     */
    fun lookupRequestConfig(body: RestLookupRequest) : RequestConfig<RestLookupRequest> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/node",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * UpdateUserMeta is used to update a node specific meta. It is used for reserved meta as well (bookmarks, contentLock)
     * 
     * @param uuid 
     * @param nodeUpdates 
     * @return RestNode
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun patchNode(uuid: kotlin.String, nodeUpdates: RestNodeUpdates) : RestNode {
        val localVarResponse = patchNodeWithHttpInfo(uuid = uuid, nodeUpdates = nodeUpdates)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestNode
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * UpdateUserMeta is used to update a node specific meta. It is used for reserved meta as well (bookmarks, contentLock)
     * 
     * @param uuid 
     * @param nodeUpdates 
     * @return ApiResponse<RestNode?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun patchNodeWithHttpInfo(uuid: kotlin.String, nodeUpdates: RestNodeUpdates) : ApiResponse<RestNode?> {
        val localVariableConfig = patchNodeRequestConfig(uuid = uuid, nodeUpdates = nodeUpdates)

        return request<RestNodeUpdates, RestNode>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation patchNode
     *
     * @param uuid 
     * @param nodeUpdates 
     * @return RequestConfig
     */
    fun patchNodeRequestConfig(uuid: kotlin.String, nodeUpdates: RestNodeUpdates) : RequestConfig<RestNodeUpdates> {
        val localVariableBody = nodeUpdates
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/node/u/{Uuid}".replace("{"+"Uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter name
     */
     enum class NamePerformAction(val value: kotlin.String) {
         @Json(name = "delete") delete("delete"),
         @Json(name = "restore") restore("restore"),
         @Json(name = "copy") copy("copy"),
         @Json(name = "move") move("move"),
         @Json(name = "extract") extract("extract"),
         @Json(name = "compress") compress("compress");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Trigger an action on the tree. Returns a JobInfo describing a background task.
     * 
     * @param name 
     * @param parameters 
     * @param jobUuid  (optional)
     * @return RestActionResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun performAction(name: NamePerformAction, parameters: RestActionParameters, jobUuid: kotlin.String? = null) : RestActionResponse {
        val localVarResponse = performActionWithHttpInfo(name = name, parameters = parameters, jobUuid = jobUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestActionResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Trigger an action on the tree. Returns a JobInfo describing a background task.
     * 
     * @param name 
     * @param parameters 
     * @param jobUuid  (optional)
     * @return ApiResponse<RestActionResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun performActionWithHttpInfo(name: NamePerformAction, parameters: RestActionParameters, jobUuid: kotlin.String?) : ApiResponse<RestActionResponse?> {
        val localVariableConfig = performActionRequestConfig(name = name, parameters = parameters, jobUuid = jobUuid)

        return request<RestActionParameters, RestActionResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation performAction
     *
     * @param name 
     * @param parameters 
     * @param jobUuid  (optional)
     * @return RequestConfig
     */
    fun performActionRequestConfig(name: NamePerformAction, parameters: RestActionParameters, jobUuid: kotlin.String?) : RequestConfig<RestActionParameters> {
        val localVariableBody = parameters
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (jobUuid != null) {
                    put("JobUuid", listOf(jobUuid.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/node/action/{Name}".replace("{"+"Name"+"}", encodeURIComponent(name.value.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Search a list of meta by node Id or by User id and by namespace
     * 
     * @param body 
     * @return RestUserMetaList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchMeta(body: IdmSearchUserMetaRequest) : RestUserMetaList {
        val localVarResponse = searchMetaWithHttpInfo(body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestUserMetaList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Search a list of meta by node Id or by User id and by namespace
     * 
     * @param body 
     * @return ApiResponse<RestUserMetaList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchMetaWithHttpInfo(body: IdmSearchUserMetaRequest) : ApiResponse<RestUserMetaList?> {
        val localVariableConfig = searchMetaRequestConfig(body = body)

        return request<IdmSearchUserMetaRequest, RestUserMetaList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchMeta
     *
     * @param body 
     * @return RequestConfig
     */
    fun searchMetaRequestConfig(body: IdmSearchUserMetaRequest) : RequestConfig<IdmSearchUserMetaRequest> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/node/meta",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * List available templates for hydrating empty files
     * 
     * @param templateType  (optional)
     * @return RestListTemplatesResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templates(templateType: kotlin.String? = null) : RestListTemplatesResponse {
        val localVarResponse = templatesWithHttpInfo(templateType = templateType)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestListTemplatesResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List available templates for hydrating empty files
     * 
     * @param templateType  (optional)
     * @return ApiResponse<RestListTemplatesResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templatesWithHttpInfo(templateType: kotlin.String?) : ApiResponse<RestListTemplatesResponse?> {
        val localVariableConfig = templatesRequestConfig(templateType = templateType)

        return request<Unit, RestListTemplatesResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templates
     *
     * @param templateType  (optional)
     * @return RequestConfig
     */
    fun templatesRequestConfig(templateType: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (templateType != null) {
                    put("TemplateType", listOf(templateType.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/node/templates",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Add/delete a values for a given namespace
     * 
     * @param namespace List persisted values for this namespace
     * @param operation 
     * @return RestNamespaceValuesResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateNamespaceValues(namespace: kotlin.String, operation: RestNamespaceValuesOperation) : RestNamespaceValuesResponse {
        val localVarResponse = updateNamespaceValuesWithHttpInfo(namespace = namespace, operation = operation)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestNamespaceValuesResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Add/delete a values for a given namespace
     * 
     * @param namespace List persisted values for this namespace
     * @param operation 
     * @return ApiResponse<RestNamespaceValuesResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateNamespaceValuesWithHttpInfo(namespace: kotlin.String, operation: RestNamespaceValuesOperation) : ApiResponse<RestNamespaceValuesResponse?> {
        val localVariableConfig = updateNamespaceValuesRequestConfig(namespace = namespace, operation = operation)

        return request<RestNamespaceValuesOperation, RestNamespaceValuesResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateNamespaceValues
     *
     * @param namespace List persisted values for this namespace
     * @param operation 
     * @return RequestConfig
     */
    fun updateNamespaceValuesRequestConfig(namespace: kotlin.String, operation: RestNamespaceValuesOperation) : RequestConfig<RestNamespaceValuesOperation> {
        val localVariableBody = operation
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/node/meta/namespace/{Namespace}".replace("{"+"Namespace"+"}", encodeURIComponent(namespace.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Update public link settings
     * 
     * @param uuid For Updates only
     * @param link Public link definition
     * @param passwordEnabled Whether it has Password enabled (optional)
     * @param createPassword Set if switching from no password to password (optional)
     * @param updatePassword Set if updating an existing password (optional)
     * @param updateCustomHash Change the ShareLink Hash with a custom value (optional)
     * @return RestShareLink
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updatePublicLink(uuid: kotlin.String, link: RestShareLink, passwordEnabled: kotlin.Boolean? = null, createPassword: kotlin.String? = null, updatePassword: kotlin.String? = null, updateCustomHash: kotlin.String? = null) : RestShareLink {
        val localVarResponse = updatePublicLinkWithHttpInfo(uuid = uuid, link = link, passwordEnabled = passwordEnabled, createPassword = createPassword, updatePassword = updatePassword, updateCustomHash = updateCustomHash)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestShareLink
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update public link settings
     * 
     * @param uuid For Updates only
     * @param link Public link definition
     * @param passwordEnabled Whether it has Password enabled (optional)
     * @param createPassword Set if switching from no password to password (optional)
     * @param updatePassword Set if updating an existing password (optional)
     * @param updateCustomHash Change the ShareLink Hash with a custom value (optional)
     * @return ApiResponse<RestShareLink?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updatePublicLinkWithHttpInfo(uuid: kotlin.String, link: RestShareLink, passwordEnabled: kotlin.Boolean?, createPassword: kotlin.String?, updatePassword: kotlin.String?, updateCustomHash: kotlin.String?) : ApiResponse<RestShareLink?> {
        val localVariableConfig = updatePublicLinkRequestConfig(uuid = uuid, link = link, passwordEnabled = passwordEnabled, createPassword = createPassword, updatePassword = updatePassword, updateCustomHash = updateCustomHash)

        return request<RestShareLink, RestShareLink>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updatePublicLink
     *
     * @param uuid For Updates only
     * @param link Public link definition
     * @param passwordEnabled Whether it has Password enabled (optional)
     * @param createPassword Set if switching from no password to password (optional)
     * @param updatePassword Set if updating an existing password (optional)
     * @param updateCustomHash Change the ShareLink Hash with a custom value (optional)
     * @return RequestConfig
     */
    fun updatePublicLinkRequestConfig(uuid: kotlin.String, link: RestShareLink, passwordEnabled: kotlin.Boolean?, createPassword: kotlin.String?, updatePassword: kotlin.String?, updateCustomHash: kotlin.String?) : RequestConfig<RestShareLink> {
        val localVariableBody = link
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (passwordEnabled != null) {
                    put("PasswordEnabled", listOf(passwordEnabled.toString()))
                }
                if (createPassword != null) {
                    put("CreatePassword", listOf(createPassword.toString()))
                }
                if (updatePassword != null) {
                    put("UpdatePassword", listOf(updatePassword.toString()))
                }
                if (updateCustomHash != null) {
                    put("UpdateCustomHash", listOf(updateCustomHash.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/node/link/{Uuid}".replace("{"+"Uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Special API for Bookmarks, will load userMeta and the associated nodes, and return as a node list
     * 
     * @param all  (optional)
     * @return RestNodeCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userBookmarks(all: kotlin.Boolean? = null) : RestNodeCollection {
        val localVarResponse = userBookmarksWithHttpInfo(all = all)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestNodeCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Special API for Bookmarks, will load userMeta and the associated nodes, and return as a node list
     * 
     * @param all  (optional)
     * @return ApiResponse<RestNodeCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun userBookmarksWithHttpInfo(all: kotlin.Boolean?) : ApiResponse<RestNodeCollection?> {
        val localVariableConfig = userBookmarksRequestConfig(all = all)

        return request<Unit, RestNodeCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation userBookmarks
     *
     * @param all  (optional)
     * @return RequestConfig
     */
    fun userBookmarksRequestConfig(all: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (all != null) {
                    put("All", listOf(all.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/node/bookmarks",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
